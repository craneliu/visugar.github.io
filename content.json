{"meta":{"title":"Visugar个人博客","subtitle":"书写前端，记录心情，以及碎碎念 ~","description":"前端技术，个人博客，记录心情,visugar","author":"张小花","url":"http://visugar.com"},"pages":[{"title":"","date":"2017-05-18T09:08:15.601Z","updated":"2017-05-06T12:16:34.247Z","comments":true,"path":"404.html","permalink":"http://visugar.com/404.html","excerpt":"","text":"404"},{"title":"关于我","date":"2017-05-04T03:35:11.000Z","updated":"2017-05-08T01:19:34.120Z","comments":true,"path":"about/index.html","permalink":"http://visugar.com/about/index.html","excerpt":"","text":"爱捣腾爱码字爱购物爱看剧爱五月天的可是啥也不会的女汉纸一枚 期待很多很多包辣条成为小花的嫁妆 ~"},{"title":"更新日志","date":"2017-05-04T02:00:11.000Z","updated":"2017-06-09T12:35:30.221Z","comments":true,"path":"board/index.html","permalink":"http://visugar.com/board/index.html","excerpt":"","text":"2017-06-09《原生JS实现省市区（县）三级联动选择》 发布 2017-06-08《select表单元素详解及下拉列表模拟实现》 发布 2017-05-17《CSS3饼状loading效果 》 发布 2017-05-11《RegExp（正则表达式）常用要点小结》 发布 2017-05-10《中文技术文档规范-改自阮一峰老师》 发布 2017-05-06《菜鸟张小花之多种前端布局实现》发布 2017-05-04《hexo从零开始到搭建完整》的完成 2017-05-04使用hexo搭建博客，使用的主题是hueman，有很多地方还不完善，后期继续努力！"}],"posts":[{"title":"拖放API中的drag和drop实战","slug":"20170725DragAndDrop","date":"2017-07-25T11:35:17.000Z","updated":"2017-07-27T12:37:03.485Z","comments":true,"path":"2017/07/25/20170725DragAndDrop/","link":"","permalink":"http://visugar.com/2017/07/25/20170725DragAndDrop/","excerpt":"","text":"写在前面在HTML5之前，实现拖放功能需要借助mousedown/mousemove/mouseover/mouseout/mouseup等鼠标事件来完成，HTML5中拖放API的出现使很多事情变简单。下面是做笔记做笔记~ 源码地址 栗子预览1 栗子预览2 栗子预览3 拖放过程拖放：包括拖拽（drag）和释放（drop） 拖放中涉及两个元素，分别是：源对象和目标对象，如下图源对象是被拖拽的元素，目标对象是要释放到的接收元素。 拖放事件： 拖放事件流为拖放操作开始后触发的一系列事件，分为以下两类： 发生在源对象上的事件123dragstart:用户开始拖动页面中的某个元素时触发的事件drag: 源对象在拖拽过程中持续触发的事件dragend:拖动完成时触发的事件，一般用于清空拖动过程中的状态等。 发生在目标对象上的事件1234dragenter:源对象进入到目标对象时，会触发目标对象的ondragenter事件dragleave:源对象移除之前调用了dragenter的元素时，目标元素触发的事件dragover：源对象进入目标对象后持续触发的事件drop：用户释放鼠标时，drop会在目标对象上被调用 设置元素可拖动1dragable = &quot;true&quot; 传输和控–dataTransfer dataTransfer对象可用于每个拖放事件中。用于获取和设置实际放置的数据，主要属性及方法如下：1234567setData(format,data):在dragstart事件中调用此函数可以注册一个MIME类型格式的传输项。getData(format):可以获取指定类型的注册数据项。types：属性以数组形式返回所有当前注册的格式。items：返回所有项机器相关格式列表files：返回与放置相关的所有文件clearData():不带参则清空所有注册数据，带参则移除指定注册项…………等等 来点儿小栗子说小栗子前说下两点： 触发dragover事件时，需要使用preventDefault()方法阻止默认事件，drag事件才能正常触发 dataTransfer中的files属性用到了File API规范的子集，files存放了文件列表，files支持下列属性：1234name:带有扩展名的文件全名type：文件的MIME类型size：以字节为单位的文件大小lastModifiedDate：最后一次修改文件内容的时间戳 下面会用到的FileReader对象详细请移步：FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果. 1.简单的节点拖放可将任意节点拖放到其他元素上，并插入到目标元素的前面拖放前后： 主要代码：123456789101112/*目标对象上触发的dragove事件*/ drag.addEventListener(&apos;dragover&apos;, function (e) &#123; e.preventDefault(); //阻止默认动作 &#125;) /*源对象释放，目标对象上触发的事件*/ drag.addEventListener(&apos;drop&apos;, function (e) &#123; ele.classList.remove(&apos;draging&apos;); if (e.target.nodeName === &apos;LI&apos;) &#123; e.target.parentNode.insertBefore(ele, e.target); //将源对象元素插入到目标元素前面 &#125; &#125;) 2.节点清除可将龙猫丢进垃圾桶，即清除img元素节点丢龙猫前后：主要代码：1234567891011121314151617181920212223242526272829303132&lt;h3&gt;拖动龙猫到垃圾桶后从DOM树中删除子元素&lt;/h3&gt; &lt;img id=&quot;bin&quot; src=&quot;./img/default.png&quot;&gt; &lt;hr/&gt; &lt;img id=&quot;item1&quot; class=&quot;imgs&quot; src=&quot;./img/01.jpeg&quot;&gt; &lt;img id=&quot;item2&quot; class=&quot;imgs&quot; src=&quot;./img/02.jpg&quot;&gt; &lt;img id=&quot;item3&quot; class=&quot;imgs&quot; src=&quot;./img/03.jpeg&quot;&gt; &lt;script&gt; //为源对象添加事件监听 —— 记录拖动了哪一个源对象 var imgs = document.querySelectorAll(&apos;.imgs&apos;); var target = document.querySelector(&apos;#bin&apos;); for(var i=0; i&lt;imgs.length; i++)&#123; var pic = imgs[i]; pic.ondragstart = function(e)&#123; //开始拖动源对象 e.dataTransfer.setData(&apos;imgID&apos;,this.id);//保存被拖拽源的id &#125; &#125; //为目标对象添加事件监听 —— 删除拖动的源对象 target.ondragover= function(e)&#123; e.preventDefault(); //阻止默认行为 &#125; target.ondrop= function(e)&#123; //源对象松手释放在了目标对象中 //删除被拖动的源对象 var id = e.dataTransfer.getData(&apos;imgID&apos;); var p = document.getElementById(id); p.parentNode.removeChild(p); //从父元素中删除子节点 &#125; &lt;/script&gt; 3.将本地图片拖放到页面中指定区域 可将你的美图拖到网页中显示 爆照前后效果： 主要代码：1234567891011121314151617181920212223242526var content = document.querySelector(&apos;#content&apos;); document.addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); //阻止document的默认事件 &#125;); document.addEventListener(&apos;drop&apos;,function(e)&#123; e.preventDefault(); //阻止document的默认事件(阻止照片在新窗口中打开) &#125;); content.addEventListener(&apos;dragover&apos;,function(e)&#123; e.preventDefault(); &#125;) content.addEventListener(&apos;drop&apos;,function(e)&#123; var imgFs = e.dataTransfer.files[0]; //files存放了文件列表 //console.log(imgFs); var fs = new FileReader(); //创建一个FileReader对象 fs.readAsDataURL(imgFs); /*图片资源加载完成之后显示在content中*/ fs.onload = function()&#123; var img = new Image(); img.src = fs.result; content.appendChild(img); &#125; &#125;) 小结对今天学习的知识点做个记录，欢迎大佬们指正~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"拖放API","slug":"拖放API","permalink":"http://visugar.com/tags/拖放API/"},{"name":"drag","slug":"drag","permalink":"http://visugar.com/tags/drag/"},{"name":"drop","slug":"drop","permalink":"http://visugar.com/tags/drop/"}]},{"title":"JS中client/offset/scroll等的宽高解析","slug":"20170725ClienOffsetScroll","date":"2017-07-25T11:28:30.000Z","updated":"2017-07-27T12:42:53.676Z","comments":true,"path":"2017/07/25/20170725ClienOffsetScroll/","link":"","permalink":"http://visugar.com/2017/07/25/20170725ClienOffsetScroll/","excerpt":"","text":"window相关宽高属性1. window.outerHeight (窗口的外层的高度) / window.outerWidth (窗口的外层的宽度) window.outerHeight获取整个浏览器窗口的高度（单位：像素），包括侧边栏（如果存在）、窗口镶边（window chrome）和窗口调正边框。包含调试窗及浏览器边框 window.outerWidth表示整个浏览器窗口的宽度，包括侧边栏（如果存在）、窗口镶边（window chrome）和调正窗口大小的边框。包含调试窗及浏览器边框 参考链接：window.outerHeight -MDNwindow.outerWidth-MDN 2. window.innerHeight (浏览器窗口的视口的高度)和 window.innerWidth window.innerHeight浏览器窗口的视口（viewport）高度（以像素为单位），如果存在水平滚动条，则包括它。不包含调试窗及浏览器边框 window.innerWidth浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。不包含调试窗及浏览器边框 参考链接：window.innerHeight - MDNwindow.innerWidth - MDN 3. window.screen.width和window.screen.height注：在获取值时可不加window.前缀 window.screen.width声明了显示当前浏览器的屏幕的宽度，以像素计 window.screen.height声明了显示当前浏览器的屏幕的高度，以像素计 参考链接：window.screen - MDNwindow.screen - MDN 4. window.screen.availHeight和window.screen.availWidth window.screen.availHeight声明了显示浏览器的屏幕的可用高度，以像素计。除去我们底部任务栏外的屏幕高度 window.screen.availWidth声明了显示浏览器的屏幕的可用宽度，以像素计 参考链接：window.screen - MDNwindow.screen - MDN 5. window.screenTop和window.screenLeft 功能： 返回窗口的左上角在屏幕上的x坐标。该属性为只读属性。语法： window.screenLeft。注：在Firefox等浏览器中使用的是screenX属性。 返回窗口的左上角在屏幕上的y坐标。该属性为只读属性。 语法： window.screenTop。注：在Firefox等浏览器中使用的是screenY属性。 参考链接：window.screenTopwindow.screenLeft document下面的相关属性（offset/client/scroll）与client相关属性6. document.body.clientWidth或element.clientWidth 表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有的话）、边框和外边距。 该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 element.getBoundingClientRect()。 语法：var intElemClientWidth = element.clientWidth; 参考链接：Element.clientWidth - MDN 7. document.body.clientHeight或element.clientHeight 返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。 参考链接：element.clientHeight - MDN 8. document.body.clientLeft或element.clientLeft 表示一个元素的左边框的宽度，以像素表示。如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。 参考链接：Element.clientLeft - MDN 9. document.body.clientTop或element.clientTop 一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距。 参考链接：Element.clientTop 与offset相关属性这一对属性指的是元素的border+padding+content的宽度和高度 10. document.body.offsetWidth或element.offsetWidth border/padding/width三者的总宽度 参考链接：HTMLElement.offsetWidth 11. document.body.offsetHeight或element.offsetHeight border/padding/width三者的总高度，且是一个整数。 参考链接：HTMLElement.offsetHeight 12. HTMLElement.offsetLeft和HTMLElement.offsetTop这两个属性是基于offsetParent的 如果当前元素的父级元素没有进行CSS定位（position为absolute或relative）,offsetParent为body. 假如当前元素的父级元素中有CSS定位，offsetParent取最近的那个父级元素。 offsetLeft返回当前元素左上角相对于 HTMLElement.offsetParent 节点的左边界偏移的像素值。 offsetTop返回当前元素相对于其 offsetParent 元素的顶部的距离。 在IE6/7中：1offsetLeft=(offsetParent的padding-left)+(当前元素的margin-left) 在IE8/9/10及Chrome中：1offsetLeft=(offsetParent的margin-left)+(offsetParent的border宽度)+(offsetParent的padding-left)+(当前元素的margin-left) 在FireFox中：1offsetLeft=(offsetParent的margin-left)+(当前元素的margin-left)+(offsetParent的padding-left) 参考链接：HTMLElement.offsetLeftHTMLElement.offsetTop 与scroll相关属性13. document.body.scrollWidth及document.body.scrollHeightbody与普通element不一样 给定body宽高 &lt; 浏览器窗口时：12scrollWidth = 浏览器窗口宽度scrollHeight = 浏览器窗口高度 给定body宽高大于浏览器窗口，且内容小于给定body宽高时：12scrollWidth = 给定的宽度 + body所有padding + body所有margin + body所有borderscrollHeight = 给定的高度 + body所有padding + body所有margin + body所有border 给定body宽高大于浏览器窗口，且内容大于给定窗口时：12scrollWidth = 内容的宽度 + body所有padding + body所有margin + body所有borderscrollHeight = 内容的高度 + body所有padding + body所有margin + body所有border 参考链接：Element.scrollWidth 14. element.scrollWidth和element.scrollHeight当无滚动条时：12scrollWidth = clientWidth = 元素宽度 + padding和scrollHeight = clientHeight = 元素高度 + padding和 当有滚动条时：12scrollWidth = 实际内容的宽度 + padding和scrollHeight = 实际内容的高度 + padding和 15. document.body.scrollTop及document.body.scrollLeft 这对属性是可读写（可被重新赋值） 的 指的是当元素其中的内容超出其宽高的时候，元素被卷起来的高和宽度。 对于element元素同样适用 16. window.scrollY及window.scrollX window.scrollY 文档从顶部开始滚动过的像素值 / window.scrollX 文档从左侧开始滚动的像素值。 event中的五种坐标1、clientX及clientY：相对于浏览器（可视区左上角0,0）的坐标 2、screenX和screenY：相对于设备屏幕左上角（0,0）的坐标 3、offsetX和offsetY：相对于事件源左上角（0,0）的坐标 4、pageX和pageY：相对于整个网页左上角（0,0）的坐标 参考来源： 视频课程：JS/jQuery宽高的理解和应用 博客：JavaScript中的各种宽高属性","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"width/height","slug":"width-height","permalink":"http://visugar.com/tags/width-height/"},{"name":"offset/client/scroll","slug":"offset-client-scroll","permalink":"http://visugar.com/tags/offset-client-scroll/"}]},{"title":"css实现鼠标悬浮字体流光背景模糊效果","slug":"20170626FontLightBlur","date":"2017-06-26T10:36:31.000Z","updated":"2017-06-26T10:39:10.234Z","comments":true,"path":"2017/06/26/20170626FontLightBlur/","link":"","permalink":"http://visugar.com/2017/06/26/20170626FontLightBlur/","excerpt":"","text":"写在前面有的时候感觉写点小玩意儿挺开心的，还能实践很多的小知识点，所以这次学着写了个有趣的鼠标悬浮模糊效果，只使用了css额。 效果图 源码地址→传送门 预览地址→传送门 小知识点filter: blur(npx); 这个过滤器用来将图片模糊，但是兼容性不太好，n代表模糊度，值越大越模糊。 background-clip: text; background-clip是用于背景图片的裁剪，决定背景从哪里开始显示。当设置为text时，即可将背景设置在字体上。 text-fill-color 这个属性为字体颜色填充，在这里设置成transparent,然后在自己填充一个颜色渐变的字体颜色。 linear-gradient 线性渐变，这里为文字添加一个渐变色，为了实现流光渐变的效果，需要将背景宽度设置为200%，且linear-gradient的0%和100%颜色一样，便于前后衔接上，具体如下：12background-image: -webkit-linear-gradient(left, red, yellow 25%, red 50%, yellow 75%, red 100%);background-size: 200% 100%; 在设置好背景色之后为字体添加动画，使文字产生流光效果。 鼠标悬浮显示和隐藏现将元素的透明度设为0，当鼠标悬浮时执行渐变透明度变为1。 边框向两边伸展的效果 在实际中我们只能设置边框的宽度，而不能改变边框的长度，所以此处不能直接用border的属性。而是通过追加2个元素，并改变其大小来实现本元素的边框向两边伸展的效果。分别设置这两个元素的上下边框及左右边框。原理图(实现为所设边框，虚线为不设置边宽)： 追加元素的实现追加元素宽或高为0，当鼠标移动到box上时，宽或高渐变到100%，即可。1234567891011121314151617#content:before &#123; content: &quot; &quot;; position: absolute; left: 50%; top: 0; width: 0; height: 100%; border: 3px solid #fff; border-left: none; border-right: none; transition: all 0.8s; box-sizing: border-box; &#125;#box:hover #content:before &#123; width: 100%; left: 0; &#125; 左和右边框同理实现。 小结以前感觉好多属性用不上，这下用上了好多个，以后继续写写写~","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"CSS3","slug":"CSS3","permalink":"http://visugar.com/tags/CSS3/"}]},{"title":"原生JS实现省市区（县）三级联动选择","slug":"20170609ThreeLevel","date":"2017-06-09T12:28:08.000Z","updated":"2017-07-27T12:31:39.312Z","comments":true,"path":"2017/06/09/20170609ThreeLevel/","link":"","permalink":"http://visugar.com/2017/06/09/20170609ThreeLevel/","excerpt":"","text":"写在前面前段时间写一个关于天气的东西，里面的省市区（县）城市选择让我很头疼，在网上搜索出来大都是借助插件或者第三方库，感觉这样做代码会很重，所以索性就把几种城市选择的方式实现一遍，以备日后的不时之需。这三种方法都是针对pc端的，并且都是使用原生js实现的，连jq都没使用，于是代码有点繁琐额（尴尬）。。。。不过还是让我把原理讲完吧。 源代码地址→传送门 预览地址→传送门 方法一：下拉选择框实现省市区（县）三级联动用下拉框实现省市区三级联动是很常见的一种方式，也很方便。这里需要先了解下select的相关属性及其对象属性，请参考此文 先看下最终实现效果图： 思路介绍： 页面加载时，动态获取省份列表并放到下拉菜单的下拉项中：1234567891011 /*自动加载省份列表*/(function showProv() &#123; btn.disabled = true; var len = provice.length; for (var i = 0; i &lt; len; i++) &#123; var provOpt = document.createElement(&apos;option&apos;); provOpt.innerText = provice[i][&apos;name&apos;]; provOpt.value = i; prov.appendChild(provOpt); &#125;&#125;)(); 当点击省份列表中的某一项，此时触发省份下拉框的onchange事件，在onchange事件中根据前面所选的省份来显示对应城市。这里用到一个select的selectedIndex属性，从而获取刚刚点击的是哪个省份（生成省份列表时添加了value属性值）：1var val = obj.options[obj.selectedIndex].value; //这里得到的是所选择省份在所有下拉项中为第几项 当点击城市列表中的某一项时，原理同上（此处不赘述）选择城市时存在两种情况，如何城市选项下不存在县区，则直接将所选省市显示在输入框，否则依照上诉原理显示县区123456&lt;!--方法是判断县区的length是否为0--&gt;var countryLen = provice[current.prov][&quot;city&quot;][val].districtAndCounty.length; if(countryLen == 0)&#123; addrShow.value = provice[current.prov].name + &apos;-&apos; + provice[current.prov][&quot;city&quot;][current.city].name; return; &#125; 最后点击县区后再按确定，则可将所选地点显示在输入框中。 注意: 在未选中具体县区时，按钮为不可点状态 具体的实现主要根据城市数据来进行更细的处理。 说明： 这里使用的省市区数据来源于网络，不能保证真实性及完整性，仅供案例使用 此处使用的数据类型为js数组,格式参考如下（完整版）： 123456789101112131415161718192021222324252627282930var provice = [ &#123; name: &quot;北京市&quot;, city: [ &#123; name: &quot;北京市&quot;, districtAndCounty: [&quot;东城区&quot;, &quot;西城区&quot;, &quot;崇文区&quot;, &quot;宣武区&quot;, &quot;朝阳区&quot;, &quot;丰台区&quot;, &quot;石景山区&quot;, &quot;海淀区&quot;, &quot;门头沟区&quot;, &quot;房山区&quot;, &quot;通州区&quot;, &quot;顺义区&quot;, &quot;昌平区&quot;, &quot;大兴区&quot;, &quot;怀柔区&quot;, &quot;平谷区&quot;, &quot;密云县&quot;, &quot;延庆县&quot;, &quot;延庆镇&quot;] &#125; ] &#125;, ...... &#123; name: &quot;河北省&quot;, city: [ &#123; name: &quot;石家庄市&quot;, districtAndCounty: [&quot;长安区&quot;, &quot;桥东区&quot;, &quot;桥西区&quot;, &quot;新华区&quot;, &quot;裕华区&quot;, &quot;井陉矿区&quot;, &quot;辛集市&quot;, &quot;藁城市&quot;, &quot;晋州市&quot;, &quot;新乐市&quot;, &quot;鹿泉市&quot;, &quot;井陉县&quot;, &quot;微水镇&quot;, &quot;正定县&quot;, &quot;正定镇&quot;, &quot;栾城县&quot;, &quot;栾城镇&quot;, &quot;行唐县&quot;, &quot;龙州镇&quot;, &quot;灵寿县&quot;, &quot;灵寿镇&quot;, &quot;高邑县&quot;, &quot;高邑镇&quot;, &quot;深泽县&quot;, &quot;深泽镇&quot;, &quot;赞皇县&quot;, &quot;赞皇镇&quot;, &quot;无极县&quot;, &quot;无极镇&quot;, &quot;平山县&quot;, &quot;平山镇&quot;, &quot;元氏县&quot;, &quot;槐阳镇&quot;, &quot;赵县&quot;, &quot;赵州镇&quot;] &#125;, ....... &#123; name: &quot;邯郸市&quot;, districtAndCounty: [&quot;丛台区&quot;, &quot;邯山区&quot;, &quot;复兴区&quot;, &quot;峰峰矿区&quot;, &quot;武安市&quot;, &quot;邯郸县&quot;, &quot;南堡乡东小屯村&quot;, &quot;临漳县&quot;, &quot;临漳镇&quot;, &quot;成安县&quot;, &quot;成安镇&quot;, &quot;大名县&quot;, &quot;大名镇&quot;, &quot;涉县&quot;, &quot;涉城镇&quot;, &quot;磁县&quot;, &quot;磁州镇&quot;, &quot;肥乡县&quot;, &quot;肥乡镇&quot;, &quot;永年县&quot;, &quot;临洺关镇&quot;, &quot;邱县&quot;, &quot;新马头镇&quot;, &quot;鸡泽县&quot;, &quot;鸡泽镇&quot;, &quot;广平县&quot;, &quot;广平镇&quot;, &quot;馆陶县&quot;, &quot;馆陶镇&quot;, &quot;魏县&quot;, &quot;魏城镇&quot;, &quot;曲周县&quot;, &quot;曲周镇&quot;] &#125; ] &#125;] 方法二：按级选中省市县/区 这种方式比上面的下拉框更好看点，操作也更方便点，不过大概的逻辑有点类似。所用省市区数据跟上面的一致。 先看看这种方式的效果图： 在页面加载时同样先显示出所有的省份列表（方法类似） 点击具体省份时，将省份列表替换成对应的城市列表，点击具体城市时显示对应县区，实现如下：1234567891011121314151617181920212223242526addrWrap.onclick = function (e) &#123; //将点击事件委托给列表的父元素 var n; var e = e || window.event; var target = e.target || e.srcElement; if (target &amp;&amp; target.nodeName == &apos;LI&apos;) &#123; /*先判断当前显示区域显示的是省市区的那部分*/ for (var z = 0; z &lt; 3; z++) &#123; if (titleWrap[z].className == &apos;titleSel&apos;) n = z; &#125; /*显示的处理函数*/ switch (n) &#123; case 0: showCity2(target.index); //点击的是省份中列表的某一项，接下来则显示城市列表 break; case 1: showCountry2(target.index); //点击的是城市列表中的某一项，接下来则显示县区列表 break; case 2: selectCountry(target.index); //点击具体的某个县区，则将该县区选择 break; default: showProv2(); &#125; &#125;&#125;; 5.上面点击的每一步中将选中项的索引及值保存在一个对象中，以便最后点击确定按钮将选择的省市区显示在输入框中。6.当选择的城市不存在县区时处理跟第一种方式一致。7.当点击分类时，显示对应的内容，同时将保存的对象的值进行处理：12345678//将事件委托给父元素,根据点击的分类进行处理（html的设置好li的value值）if (target.value == &apos;0&apos;) &#123; showProv2();&#125; else if (target.value == &apos;1&apos;) &#123; showCity2(current2.prov);&#125; else &#123; showCountry2(current2.city);&#125; 8.OK 方法三：按字母顺序选中城市 直接按字母的顺序选中城市这种方式比前两种更简单粗暴也较为简单，代码量也较少。 先看看这种方式的效果图： 页面加载时先显示热门城市 点击不同字母集，显示对应的城市列表12345678910switch (index) &#123; case 0: //0为热门项 showHotCity(); break; case 6: //6为最后一栏，字母集个数为2 showCitys(index, 2); break; default: //其余索引，字母集个数都为4 showCitys(index, 4); &#125; 12345678function showCitys(index, m) &#123; //通过传入的参数截取城市数据的一部分为当前要显示的城市列表 var currentAll = cityAll.slice(4 * index - 3, 4 * index + m - 3); ..... //将动态生成的列表项放到显示区域&#125; 5.点击具体某一个城市时，将其显示在输入框中。6.这种方式的城市数据跟前两种不同，来源于网上，不能保证真实性及完整性，仅供案例使用，数据格式如下（完整版）： 1234567891011121314151617var cityAll = [ &#123; name: &quot;hot&quot;, citys: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;, &quot;杭州&quot;, &quot;南京&quot;, &quot;成都&quot;, &quot;重庆&quot;, &quot;武汉&quot;, &quot;长沙&quot;, &quot;昆明&quot;] &#125;, &#123; name: &quot;A&quot;, citys: [&quot;阿坝&quot;, &quot;阿拉善&quot;, &quot;阿里&quot;, &quot;安康&quot;, &quot;安庆&quot;, &quot;鞍山&quot;, &quot;安顺&quot;, &quot;安阳&quot;, &quot;澳门&quot;] &#125;, ...... &#123; name: &quot;Z&quot;, citys: [&quot;杂多县&quot;, &quot;赞皇县&quot;, &quot;枣强县&quot;, &quot;枣阳市&quot;, &quot;枣庄&quot;,.......,资阳&quot;]&#125; 7.完美~ 小结 详细代码看上面给出了链接，有注释的额（firefox和chrome可正常显示）~ 这几种实现方式为一己之见，欢迎大佬们指点，如有更好的可以告诉我，我来完善完善~ 有人能告诉我怎么做gif图么？","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"select","slug":"select","permalink":"http://visugar.com/tags/select/"},{"name":"省市区三级联动","slug":"省市区三级联动","permalink":"http://visugar.com/tags/省市区三级联动/"},{"name":"JS","slug":"JS","permalink":"http://visugar.com/tags/JS/"}]},{"title":"select表单元素详解及下拉列表模拟实现","slug":"20170608SelectList","date":"2017-06-08T11:45:10.000Z","updated":"2017-07-27T12:26:42.937Z","comments":true,"path":"2017/06/08/20170608SelectList/","link":"","permalink":"http://visugar.com/2017/06/08/20170608SelectList/","excerpt":"","text":"写在前面select 是HTML表单元素中很常用的一个，其中很重要的几个属性常被忽略，但这几个属性却能帮助我们完成很多的功能，当然，select下拉列表默认样式很不友好，所以更多的时候可以自己模拟实现一个同样功能的下拉菜单。下文先介绍select标签的一些属性及使用，后面再模拟一个相同效果的下拉菜单。 介绍之前先看下demo预览图： 1.firefox下select的默认样式： 2.chrome下select的默认样式： 3.firefox下自定义select下拉列表的icon效果： 4.chrome下自定义select下拉列表的icon效果： 5.原生js模拟select下拉列表的实现效果(chrome及firefox效果一致)： 源代码地址→传送门 预览地址→传送门 1. select表单元素及相关属性（我只是大自然的搬运工）提示select 元素是一种表单控件，可用于在表单中接受用户输入支持的全局属性 仅挑几个属性 autofocus(其值为autofocus): 规定在页面加载后文本区域自动获得焦点。 disabled(值为disabled): 规定禁用该下拉列表。 form(值为form_id): 规定文本区域所属的一个或多个表单。 multiple(值为multiple): 规定可选择多个选项。 支持的事件属性 挑一个最常用到的额 onchange：当select改变选择时调用的事件句柄。(可以实现三级联动的效果) selected对象的属性及方法 挑几个重要的额 options[]：返回包含下拉列表中的所有选项的一个数组。 length：返回下拉列表中的选项数目。 selectIndex：设置或返回下拉列表中被选项目的索引号。 add(): 向下拉列表添加一个选项。 remove(): 从下拉列表中删除一个选项。 option标签 option元素定义下拉列表中的一个选项（一个条目）。 disabled(值为disabled)：规定此选项应在首次加载时被禁用。 label(值为text)：定义当使用 时所使用的标注。 selected)(值为selected)：规定选项（在首次显示在列表中时）表现为选中状态。 value(text): 定义送往服务器的选项值。 option对象的属性 几个比较重要的额 defaultSelected：返回 selected 属性的默认值。 disabled:设置或返回选项是否应被禁用。 index：返回下拉列表中某个选项的索引位置。 selected：设置或返回 selected 属性的值。 注意： select本身的样式可用css设置，但对option设置的样式在chrome中不起作用，在Firefox可行 w3c官网的详细解释 → 传送门 2. HTML标签自定义属性（纯属题外话）HTML5 data-*自定义属性：添加data-前缀使属性变成自定义属性，最大的好处是我们可以把所有自定义属性在dataset对象中统一管理。 1234567&lt;div id=&quot;student&quot; data-weight=&quot;98&quot;&gt;点击显示&lt;/div&gt;var student = document.getElementById(&quot;student&quot;);student.dataset.cm = &apos;168&apos;; //设置自定义属性var stuWeight = studdent.dataset.weight; //获取自定义属性值student.dataset.birthDate = &apos;19980612&apos;; //连字符的自定义属性 (例如设置data-birth-date) 3. 自定义下拉列表的图标select默认样式中的下拉按钮不是很好看，我们可以自己用替张图片替换掉。（效果看文章上面的链接，请忽略我的丑丑的图标额） 1.对select自定义图标时需要设置apperance属性为none(隐藏原有小三角)，并做兼容 2.加上将要替换的自定义图标即可 12345select&#123; -webkit-appearance: none; /*隐藏默认样式中的小三角*/ -moz-appearance: none; background: url(&apos;http://opif0c56u.bkt.clouddn.com/select.gif&apos;) no-repeat scroll right 8px center;&#125; 3.可对option添加背景色 4.在firefox中可使用伪元素:before对option添加序号（此处插播一个css添加序号的方法）1234567select&#123; counter-reset: item; //类似于声明计数变量（声明在父元素中）&#125;select option:before &#123; counter-increment: item; //要使用的计数名 content: counter(item) &quot; . &quot;; //追加前置序号,chrome对option的设置中不起作用&#125; 4. js模拟select下拉菜单(重头戏)许多时候会觉得select表单特别的不好用，不能自己添加很多的样式，小伙伴们还是自己模拟一个吧！ 1.html代码结构： 12345678910&lt;div id=&quot;sel-wrap&quot;&gt; &lt;div id=&quot;sel-show&quot;&gt;=请选择=&lt;/div&gt; &lt;ul id=&quot;sel-option&quot;&gt; &lt;li class=&quot;item&quot;&gt;早上吃包子&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;中午吃米饭&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;晚上吃面条&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;宵夜吃烧烤&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;睡前喝牛奶&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2.下拉按钮的图标跟上面自定义的方式一致（这里不再说了）。 3.hover到li上时，利用伪元素:before追加一个对勾。 123#sel-option li:hover:before &#123; content: &apos;\\2714&apos; &apos; &apos;; //此处为对勾+空格 &#125; 4.下面说下实现原理： 下拉菜单的选项为ul中的内容，需要先隐藏起来，且显示的时候是浮在其他内容的上面，此处需要使用position来实现。（即脱离文档流）123456#sel-wrap&#123; position: relative; //设置父元素&#125;#sel-option&#123; position: absolute; //设置下拉列项的包裹层&#125; 点击下拉框时显示下拉列表项 点击列表项时将选中值传递给下拉框并显示，同时下拉项收起（此处的点击事件绑定在父元素中） 当下拉项显示并未选中任何下拉项时，点击下拉框收起下拉项 当下拉项显示并未选中任何下拉项时，点击下拉项以外的任意位置，收起下拉框 最终实现（样式什么的都可以随便改）： 小结 小花作为菜鸟第一次自己模拟下拉列表的实现，有可能存在代码欠缺，但是为了方便以后使用的时候查询，所以就记录下 欢迎大佬们指点","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"css3","slug":"css3","permalink":"http://visugar.com/tags/css3/"},{"name":"select","slug":"select","permalink":"http://visugar.com/tags/select/"}]},{"title":"预览github项目的html文件新方法","slug":"20170519PreviewHtml","date":"2017-05-19T04:32:01.000Z","updated":"2017-07-27T12:21:35.055Z","comments":true,"path":"2017/05/19/20170519PreviewHtml/","link":"","permalink":"http://visugar.com/2017/05/19/20170519PreviewHtml/","excerpt":"","text":"写在前面关于如何在线预览github中的html文件，其实这是一个很多人知道的东西，但是查资料的时候呢总是找不到正确的答案，并且一开始我也是踩了坑的。 踩坑经历搜出来的结果大概就两种： 第一种是在你打开的源码地址的url地址基础上加http://htmlpreview.github.io/?或者http://htmlpreview.github.com/?(注：填这个还是会转到前面那个前缀去的)前缀。 第二种就是在你的项目branch上添加一个gh-pages分支，然后将你的项目复制一份到这个分支上，然后再进入settings的github pages进行设置就OK了。 总结下上面两种，添加前缀的方式确实比较简单，但是东西多了就会加载很慢，甚至不能正确的显示css样式，对于显示js的效果就更不使用了。所以，赶快放弃吧！创建分支的方式确实是很麻烦额，之前就是感觉麻烦的不得了所以没用这种方式，接下来要介绍的是创建分支的升级版，看下文~ 取经啦一度感觉小花说话很麻烦，请不要见怪！！！ 第一步就是找到你要展示的repo中的Settings 找到github pages那一栏,在Source中选择master branch,然后save 放大你的眼睛找到你自己的这串地址 然后就可以愉快的预览了 完美~ 小结刚开始自己踩坑发现不对劲但又苦于找不到解决方法，后来偶然有个同学告诉我这样纸，所以，我就只是枚小小的搬运工而已~ 给看完本文的孩纸们一个爱的么么哒","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"github","slug":"github","permalink":"http://visugar.com/tags/github/"}]},{"title":"CSS3饼状loading效果","slug":"20170517RoundLoading","date":"2017-05-17T00:36:33.000Z","updated":"2017-05-18T11:45:40.519Z","comments":true,"path":"2017/05/17/20170517RoundLoading/","link":"","permalink":"http://visugar.com/2017/05/17/20170517RoundLoading/","excerpt":"","text":"写在前面（附录有源码及效果） 之前碰到一个小练习，就是用纯CSS3来写饼状的loading效果，之前着实没有写过这玩意儿，小花完全没头绪，然后参考了张鑫旭老师的CSS3实现鸡蛋饼饼状图loading等待转转转，还有些别的东西，用一种看起来有一点类似但是好像又不一样的方式完成了同样的效果，题目要求的大概就是这个样子： 开始琢磨了一下，睡一觉起来画了个图，理顺了一下，不过感觉此图有点难意会啊啊啊啊啊，没关系，小花会在后文一点一点解释哒~(红跟粉代表颜色，斜杠后面是z-index的值) 原理这个东西分为两部分：外圈和内圆。颜色这东西都自定义啦，不过我画的的圈圈好像有点太大，然后动画时间是随便设的，反正转起来看着感觉有点怪怪的额 先上html结构12345678910111213&lt;div class=&quot;con-wrap&quot;&gt; &lt;!--外圈--&gt; &lt;div class=&quot;out-round&quot;&gt;&lt;/div&gt; &lt;!--内圆，里面有半圆四个--&gt; &lt;div class=&quot;in-round&quot;&gt; &lt;div class=&quot;lt-round&quot;&gt;&lt;/div&gt; &lt;div class=&quot;lt-mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;rt-round&quot;&gt;&lt;/div&gt; &lt;div class=&quot;rt-mask&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 外圈和内圆是通过position定位重合在一起，实质上外圈转完2圈，内圆的红色和粉色才各转完1圈（内圆的全程包括红色从1到0、粉色从1到0），所以内圆的动画时间应该是外圈的两倍！！！ 外圈 外圈很简单，设置border-radius:50%即可画出一个圆，然后设置三条边框为红色，另外一条为透明，即画出了四分之三个圆边框（即外圆）。123456789.out-round &#123; width: 100px; height: 100px; border-radius: 50%; margin: 150px auto; border: 3px solid #FF298C; border-left: 3px solid transparent; animation: outRound 1s linear infinite running; &#125; 接下来是外圈的动画，为其设置的动画就是旋转一圈，infinite表示无限次12345678@keyframes outRound &#123; 0% &#123; transform: rotate(120deg) &#125; 100% &#123; transform: rotate(-240deg) &#125; &#125; 其中rotate(120deg)为旋转起始位置，可根据实际情况调整。 至此外圈就完成了，比较麻烦的是下面的内圆，不过根据图示应该是可以想象的。 内圆 此处有四个半圆，左边两个，右边两个（round为红色，mask为粉色），动画主要通过改变两个红色半圆的z-index值来控制各个半圆显示的优先顺序。内圆的css实现部分为：1234567891011121314151617/*左边两个半圆*/ .lt-round, .lt-mask &#123; position: absolute; width: 35px; height: 70px; border-radius: 35px 0 0 35px; transform-origin: right center; &#125; /*右边两个半圆*/ .rt-round, .rt-mask &#123; position: absolute; left: 50%; width: 35px; height: 70px; border-radius: 0 35px 35px 0; &#125; 下面过程描述内圆的动画全程（其中右边的粉色全程不需要动，右边红色部分只需要改变z-index的值来改变显示的优先级，从而实现显示和隐藏的效果来配合补充左半边的圆。）： 1.初始设置： 12345红左 z-index：3粉1 z-index：2红右 z-index：1粉2 z-index：0 模型图： 视觉效果图(忽略中间的白线)： 2.左边红色旋转完180度时（逆时针旋转所以是360→180→0） 模型图： 视觉效果图： 3.左边红色转完到0度时（此时左右两边的红色半圆被粉色覆盖） 模型图： 视觉效果图： 4.粉色半圆重复之前红色半圆的动画（即左边粉色360→180→0） 模型图： 视觉效果图： 5.当左边粉色旋转到0度时，全部半圆回到了最初始的状态，整个动画即完成（在相同时间下外圈完成了2次的动画）。 模型图： 视觉效果图： 动画代码部分1.前半程为左边红色旋转一周，后半程为粉色旋转一周。动画实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*左边红色完成第一圈的旋转*/@keyframes ltRound &#123; 0% &#123; transform: rotate(360deg); &#125; 24.9% &#123; z-index: 3; &#125; 25% &#123; z-index: 1; transform: rotate(180deg); &#125; 50% &#123; transform: rotate(0deg); &#125; 74.9% &#123; z-index: 1; &#125; 75%, 100% &#123; z-index: 3; &#125; &#125;/*右边红色圆通过z-index来控制显示和隐藏，从而达到在适当时间配上左半圆的效果*/@keyframes rtRound &#123; 0%, 24.9% &#123; z-index: 1; &#125; 25% &#123; z-index: -3; &#125; 74.9% &#123; z-index: -3; &#125; 75%, 100% &#123; z-index: 1; &#125; &#125; /*左边粉色完成第二圈的旋转*/@keyframes ltMask &#123; 0%, 25%, 50% &#123; transform: rotate(360deg); &#125; 75% &#123; transform: rotate(180deg); &#125; 100% &#123; transform: rotate(0deg); &#125; &#125; 2.在全部代码未完成时，可以将动画时间设大一点，这样便于观察，搞完了再设回去就OK了。 3.由于动画是匀速变化的，但是z-index的值不能匀速变化，所以只能在某个很短时间内去改变z-index的值。这样才能达到效果（突然感觉这种实现好像也不是很好） 小结 没做兼容，在chrome中无异常，别的我就不太知道了 只是用来练习练习，实际上不一定会用到，但是里面几个知识点还是hei有用滴 小花是小白，对很多东西都还没整明白，欢迎大佬们指点指点~ 这几个图画的我心好累，sei能给小花推荐个好用点的额 源代码源码地址 预览地址","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"css3","slug":"css3","permalink":"http://visugar.com/tags/css3/"},{"name":"z-index","slug":"z-index","permalink":"http://visugar.com/tags/z-index/"}]},{"title":"RegExp（正则表达式）常用要点小结","slug":"20170511RegRxp","date":"2017-05-11T08:17:05.000Z","updated":"2017-05-18T11:42:05.968Z","comments":true,"path":"2017/05/11/20170511RegRxp/","link":"","permalink":"http://visugar.com/2017/05/11/20170511RegRxp/","excerpt":"","text":"正文正则表达式用到的地方很多，但是每次很久不用就全忘光了，每次都要重新看一遍文档，为了节省时间，把它的一些基本要点画总结在一张图片中，这样方便以后查看。 PS：细节的东西还是需要看详细点的文档。 原图传送门","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"文档","slug":"文档","permalink":"http://visugar.com/tags/文档/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://visugar.com/tags/正则表达式/"}]},{"title":"中文技术文档规范-改自阮一峰老师","slug":"20170510DocRule","date":"2017-05-10T01:08:30.000Z","updated":"2017-05-18T11:41:47.440Z","comments":true,"path":"2017/05/10/20170510DocRule/","link":"","permalink":"http://visugar.com/2017/05/10/20170510DocRule/","excerpt":"","text":"正文以前从来去想一篇技术文章要怎么架构，总是随自己想到什么写什么，然后看到了阮一峰老师的总结，就把它改成了思维导图，以便记忆查询。 原文地址：https://github.com/ruanyf/document-style-guide 原图传送门","categories":[{"name":"划重点","slug":"划重点","permalink":"http://visugar.com/categories/划重点/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"写作规范","slug":"写作规范","permalink":"http://visugar.com/tags/写作规范/"},{"name":"文档","slug":"文档","permalink":"http://visugar.com/tags/文档/"}]},{"title":"菜鸟张小花之多种前端布局实现","slug":"20170506Layout","date":"2017-05-06T08:09:57.000Z","updated":"2017-07-27T12:18:19.762Z","comments":true,"path":"2017/05/06/20170506Layout/","link":"","permalink":"http://visugar.com/2017/05/06/20170506Layout/","excerpt":"写在前面 由于知识有限，有的内容可能有点小错误什么的，仅供参考参考，欢迎大佬们指正","text":"写在前面 由于知识有限，有的内容可能有点小错误什么的，仅供参考参考，欢迎大佬们指正，小花在这里谢过~ 小贴士（to freshman）：给每个块都加上颜色，更好辨识。 关于代码：这里给出的都是css部分，html部分用最常规的结构就好啦 1. 水平居中方法一：margin:0 auto; （最常用的居中布局方式） 方法二：text-align和inline-block的结合（设置父元素的text-align为center）。 这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。 方法三：position绝对定位来实现居中布局。 适用于块级元素不给出宽高的情况下(需要借助transtrom的tanslateX方法)。 123456789#parent&#123; position: relative;&#125;#child&#123; position: absolute; top: 0; left: 50%; transform: translateX(-50%);&#125; 方法四：利用flex弹性布局的一个属性。 子元素宽度已知的情况下1234#parent&#123; display: flex; justify-content: center;&#125; 其他还有很多方法，一般用的不太多。并且各种方法优缺点不一样，可选择性使用。 2. 水平居中及垂直居中方法一：先说一种神奇的方式吧12341. 子元素 div 绝对定位2. 父元素需要被定位3. 子元素 top、bottom、left、right 四个位置值均为 04. 子元素 margin: auto; 下面代码是可以实现的，但还有点问题，大家帮小花看看~ 12345678910111213141516#parent&#123; width: 100%; height:100%; position: fixed;&#125;#child&#123; width: 400px; height: 200px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; background-color: #ccc;&#125; 方式二：利用position的绝对定位及负边框来实现。123456789101112131415 #parent&#123; position: fixed; width: 100%; height: 100%;&#125;#child&#123; position: absolute; left: 50%; top: 50%; width: 400px; height: 200px; margin-top: -100px; margin-left: -200px; background-color: #ccc;&#125; 对于未给出宽高的元素，又需要请transform登场了，同时需要做好各浏览器的兼容。对于我这种懒癌患者，就不给出兼容代码嘞~ 其他应该还有一些方法，暂时还没想到，等写出来了再补补（哦对了，忘了说flex了，算了还是不写了） 3. 左边固定右边自适应的两列布局我猜吧，大家对这种布局方式最熟悉不过了，平时用的也会比较多，所以呢，你们写的应该都会比我的好~ 方式一：float+margin的方式 这种方式一定要记得给父元素清除浮动啊，不然就尴尬了呢，这里插播一种全局性(这个词似乎不太对)的清除浮动的伪元素方法.1234567891011.clearfix:after &#123; content: &apos;.&apos;; height: 0; overflow: hidden; clear: both; display: block; visibility: hidden;&#125;.clearfix &#123; zoom: 1; &lt;!--hack--&gt;&#125; 看起来有点小复杂啊，这里不分析这种方法的原理，记住就好了。当然你也可以直接借助触发BFC的方式来解决（偷偷告诉你，常用的方式就是给你的父元素设置overflow: hidden;啦）。 哦+语气~好像跑偏了，说好的布局呢，见下诉代码： 1234567#left&#123; float: left; width: 100px;&#125;#right&#123; margin-left: 120px;&#125; 方式二：float+overflow的方式 这就是传说中利用BFC的规则来实现两列布局啊啊啊！ 这种方式直接不需要清除浮动什么的就可以了，也不会影响前后文，用起来比较爽丫。12345678#left&#123; float: left; width: 100px; margin-right: 20px; &lt;!--好歹留个空啊嘿嘿--&gt;&#125;#right&#123; overflow: hidden;&#125; 方式三：float+margin+position的方式 这个方式呢也用到过，但是要考虑的比较多一点，不过其实也还好。接下来请看实现代码：1234567891011121314#parent&#123; position: relative;&#125;#left&#123; float: left; width: 100px; background-color: #ccc;&#125;#right&#123; position: absolute; top: 0; left: 120px; background-color:pink;&#125; 这种方式实现起来很简单，但是对后文是有影响的，需要自己解决一下，懒小花就不写啦~ 方式四：flex方式 这个呢，坑肯定是比较多的，建议用在小范围的布局，当然某些时候用起来确实比较爽歪歪啦12345678910#parent&#123; display: flex;&#125;#left&#123; width: 100px; margin-right: 20px;&#125;#right&#123; flex: 1;&#125; 其他的吧，我暂时还没用到也没写到~网上一搜会有好多好多精讲的。 4. 左边自适应右边固定话说其实我就只写了一种方法，我都有点不好意思放上来了，不管了，小花的脸皮比较厚，不怕！ 方式一： 当然还是position 反正很多情况都可以用position来解决，但是，同时也会有一些其他问题出现，所以，自行思考用不用~123456789101112#parent &#123; position: relative;&#125;#left &#123; margin-right:220px;&#125;#right &#123; position: absolute; right:0; top:0; width: 200px;&#125; 5. 两边固定中间自适应的三列布局其实这个布局用的也挺多的啊哈，嗯，昨天写的作业就是这个！ 方式一：纯float方式注意： 左侧元素与右侧元素优先渲染，分别向左和向右浮动 中间元素在文档流的最后渲染，自动插入到左右两列元素的中间，随后设置 margin 左右边距分别为左右两列的宽度，将中间元素调整到正确的位置。 12345678910111213.left&#123; float: left; width: 200px; height: 200px;&#125;.right&#123; float: right; width: 100px; height: 100px;&#125;.middle&#123; margin:0 120px 0 220px;&#125; 但凡用float的时候都要想一下父元素上清除浮动这个问题！ 方式二：position的绝对定位 其实感觉跟float的原理差不多，都是将左右两侧的块先固定好，再对中间部分进行处理，只不过自己可以在不同情况下选择float或者position。 1234567891011121314151617181920.parent&#123; position: relative;&#125;.left&#123; position: absolute; width: 200px; height: 200px; top: 0; left: 0;&#125;.right&#123; position: absolute; top: 0; right: 0; width: 100px; height: 100px;&#125;.middle&#123; margin:0 120px 0 220px;&#125; 方式三：flex的弹性布局 不得不说的是其实很多布局都可以用flex来实现(简单粗暴嘿嘿)，但是flex的兼容性不是很好，并且还有别问题，所以保险起见还是选择常用的，这里简单介绍下。123456789101112131415.parent&#123; display: flex;&#125;.left&#123; width: 200px; height: 200px;&#125;.right&#123; width: 100px; height: 100px;&#125;.middle&#123; flex: 1; margin:0 20px;&#125; 方式四：最后该淘宝的双翼布局闪亮登场了 要注意的是这种布局方式需要将主栏优先渲染，然后再加上两边的翅膀，即双翼，不过话又说话来，虽然小花是按照这个套路写的，但也不确定自己写的就是双翼布局。为了不误人子弟，在这先说明只是参考参考哟（欢迎大佬纠正）~ 第一步，先将主栏左浮动，并设宽度为100%，即铺满父元素 第二步，将左栏左浮动，并设左外边距为-100% 第三步，将右栏左浮动，并设左外边距为负的自身宽度 第四步，设置主栏，嘿嘿，这时候不管你使用什么方法都达不到效果，解决办法就是给主栏的内容加一个包裹层，并设左右外边距为左右两侧的宽度。 第五步，好了，完美！（但是别忘了，要清除浮动哦~） 6. 是时候小结一波了 首先，每种方式都小试了一下，基本上效果是可以达到的，当然实际情况中会比较复杂，你会遇到各种各样的麻烦，祝你好运~ 每种方式的优缺点其实对于我这种萌新来说也是比较懵，只是这几天写了几个作业才想到要小小总结下的 第一次用markdown写文字棒棒哒，不要介意某写地方可能写错了","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"CSS布局","slug":"CSS布局","permalink":"http://visugar.com/tags/CSS布局/"},{"name":"web","slug":"web","permalink":"http://visugar.com/tags/web/"}]},{"title":"hexo从零开始到搭建完整","slug":"20170504SetUpHexoBlog","date":"2017-05-04T08:16:15.000Z","updated":"2017-07-27T12:08:07.074Z","comments":true,"path":"2017/05/04/20170504SetUpHexoBlog/","link":"","permalink":"http://visugar.com/2017/05/04/20170504SetUpHexoBlog/","excerpt":"前言其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放","text":"前言其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站，现在大家用hexo比较多，也比较方便，并且能使用的主题也很多，所以小花就用她啦~ 耍起来由于小花的电脑在搭建博客之前就有了各种环境，但是对于没有任何基础的人来讲，我觉得还是从源头开始讲会好一点，就像教别人做菜，总得把所有的用料及步骤说清楚对吧？（大佬们可以自动忽略啊啊啊啊~） 1. 安装Git Bash我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。下载地址 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version (写这篇博客的时候最新版本：2.12.2) 然后你就可以在这里发挥你的聪明才智了 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 下载地址(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本：1命令：node -v 又到自由发挥的时候了 3. 安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：1npm i -g hexo 安装完成后，查看版本： 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 4. 搭桥到github没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5. 一步之遥用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令：123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。 打开浏览器输入：http://localhost:4000 接着你就可以遇见天使的微笑了~ 6. 上传到github先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)：123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。 7. 绑定个人域名不想绑定的自行忽略 第一步购买域名：随便在哪个网站买一个就好了，小花是在阿里云购买的visugar.com, DNS也是顺道在那买的。 第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。 到DNS中添加一条记录： 其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)： 接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦~ 8. 修改及配置主题hexo初始化之后默认的主题是landscape , 然后你可以去这个地址里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是hueman,看起来挺不错，至少是我喜欢的类型。 跟该主题相关的配置在themes/hueman/_config.yml里面,然后根据你的需要在这配配配就行了。 有的东西我也不知道是啥玩意儿，你要多试多倒腾几次，就能意会啦!下面是针对我所选的主题的两小点(别的主题我没看，可能也是类似: 在导航栏添加点东西 例如我添加了一个更新日志的模块。 在主题的配置文件中，menu添加一栏：Board: /board。 然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。 在主题的hueman/langulages/zh-CN.yml中的index适当的位置加：board: &#39;更新日志&#39;，位置和名字是你自己设定。 重新部署，然后就OK了 在侧边栏添加点东西 回到你的主题的配置文件中，找到widgets一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫communiation且放在了第二行。 在上面所提到的zh-CN.yml文件中找到sidebar一栏，添加communiation: &#39;你要设的名称&#39;。 在hueman/layout/widget中添加一个communiation.ejs,填入模板12345678&lt;% if (site.posts.length) &#123; %&gt; &lt;div class=&quot;widget-wrap widget-list&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;sidebar.communiation&apos;) %&gt;&lt;/h3&gt; &lt;div class=&quot;widget&quot;&gt; &lt;!--这里添加你要写的内容--&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 9. 添加RSS先安装rss相关插件：npm i hexo-generator-feed 在你的项目的_config.yml配置文件下找到Extensions添加如下内容： 1234567891011# Extensions #插件和主题## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。 重新部署再打开就能看到效果啦~ 10. 添加评论先选一个你要使用的第三方评论系统，最好找个靠谱点的（我使用的是网易云跟帖）。 在主题的配置文件下找到comment，添加一行，例如我添加的是yungentie: 此处自由发挥 注册完评论系统后获取相应的代码，然后在主题的layout下找到comment新建一个ejs模板文件，名称自定义。 找到你的article.ejs模板文件，加上&lt;%- partial(&#39;comment/你刚刚取得名字&#39;) %&gt;保存。 重新部署，OK啦 11. 写文章部分 新建文章：hexo new &#39;文章名&#39;，然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。 关于具体的文章编辑你可以看下官网的介绍 至于markdown，可以自行发挥啦~ 小结一波 在哪里跌倒，就在哪里趴下，休息一会儿你会发现新大陆的哦~ 本文针对的是从来没用hexo搭建过个人博客的小伙伴，不过文中可能会有一些小错误，欢迎大佬们指正，小花不胜感激！ 感觉我好啰嗦啊，可是没办法，我就是这么爱打字丫","categories":[{"name":"Web开发","slug":"Web开发","permalink":"http://visugar.com/categories/Web开发/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://visugar.com/tags/前端/"},{"name":"hexo","slug":"hexo","permalink":"http://visugar.com/tags/hexo/"},{"name":"hueman","slug":"hueman","permalink":"http://visugar.com/tags/hueman/"}]}]}